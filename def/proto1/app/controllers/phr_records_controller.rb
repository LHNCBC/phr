require 'net/http'
# This controller manages "PHR Records".  A "PHR Record" is, conceptually, the
# entire set of data associated with a user's profile.  This controller handles
# listing, creating, archiving, exporting, and deleting PHR Records.  However,
# for entering most types of data (drugs, allergies, etc.) we have separate
# controllers for each type.  In this class, the "new", create, edit, and update
# actions act on the basic set of information (e.g. pseudonym and gender)
# requested when creating a new profile.  This class also provides access to the
# other top level data stored in the "phrs" record, which is currently just the
# pregnancy questions, through the "edit_phr" and "update_phr" actions.
class PhrRecordsController < BasicModeController
  include PhrExporter

  before_action :authorize
  before_action :load_phr_record, :except=>[:index, :archived_index, :new, :create,
    :message_managers]
  before_action :check_for_autosave, :only=>[:show, :edit]

  layout 'basic'

  @@display_labels = {} # a hash of field names to display names

  # GET /phr_records
  def index
    # This is one of the pages we let the user access to switch to the
    # basic HTML mode.  Store that preference in the session.
    session[:page_view] = 'basic' if default_html_mode?
    @phr_records = @user.active_profiles.sort{ |x, y|
       x.phr.pseudonym.downcase <=> y.phr.pseudonym.downcase
    }
    @profile_status = "active"
    @page_title = 'PHR Management'
  end

  # GET /phr_records/archived
  # Shows the list of archived PHR records
  def archived_index
    @phr_records = @user.archived_profiles.sort{ |x, y|
       x.phr.pseudonym.downcase <=> y.phr.pseudonym.downcase
    }
    @profile_status = "archived"
    @page_title = 'Archived PHRs'
  end

  # GET /phr_records/1
  # GET /phr_records/1.xml
  def show
    @page_title = "PHR Record for #{@phr_record.phr.pseudonym}"
  end

  # GET /phr_records/new
  # GET /phr_records/new.xml
  def new
    @phr_record = Profile.new
    @phr_record.phr = Phr.new
    load_new_vars
  end


  # GET /phr_records/1/edit
  # Displays a form for editing the PHR Record's basic information
  def edit
    load_edit_vars
  end


  # POST /phr_records
  # POST /phr_records.xml
  def create
    # In order to validate the PHR record, we need to associate it with a
    # user object, which requires creating a Profile record.  We do this
    # inside a transaction so we can roll back the Profile creation if the
    # Phr does not validate.
    Profile.transaction do
      @phr_record = Profile.new
      @user.profiles << @phr_record
      phr_params = params[:phr]
      # Be careful not to save the record implicitly (by assigning it to
      # @phr_record) or save_record will not see it as a new record.
      phr = Phr.new
      phr.pseudonym = phr_params[:pseudonym]
      phr.gender_C = phr_params[:gender_C]
      phr.race_or_ethnicity_C = phr_params[:race_or_ethnicity_C]
      phr.birth_date = phr_params[:birth_date]
      phr.profile_id = @phr_record.id
      if save_record(phr)
        redirect_to(phr_record_path(@phr_record), :notice =>
            'The PHR Record was created.  You may now add information to it.')
      else
        load_new_vars
        flash.now[:error] = phr.build_error_messages(@@labels)
        # We need @phr_record.phr set up, but assigning phr to @phr_record
        # (which is saved) will try to save phr again, so make a new @phr_record.
        @phr_record = Profile.new
        @phr_record.phr = phr
        render :action=>'new'
        raise ActiveRecord::Rollback
      end
    end
  end


  # PUT /phr_records/1
  # PUT /phr_records/1.xml
  def update
    phr = @phr_record.phr
    phr_params = params[:phr]

    phr.pseudonym = phr_params[:pseudonym]
    phr.gender_C = phr_params[:gender_C]
    phr.race_or_ethnicity_C = phr_params[:race_or_ethnicity_C]
    phr.birth_date = phr_params[:birth_date]

    if save_record(phr)
      redirect_to(phr_records_url, :notice =>
          "The PHR Record Basics were successfully updated for #{phr.pseudonym}.")
    else
      load_edit_vars
      flash.now[:error] = phr.build_error_messages(@@labels)
      # By doing a render rather than a redirect back to edit, we can keep
      # the user's input (in the "phr" object)
      render :action => 'edit'
    end
  end


  # DELETE /phr_records/1
  # DELETE /phr_records/1.xml
  def destroy
    name = @phr_record.phr.pseudonym
    delete_record(@phr_record.phr)
    @phr_record.soft_delete
    flash[:notice] = "Deleted record for #{name}."
    redirect_to(archived_phr_records_url)
  end


  # Returns the latest reminders of the specified profile. The reminders are
  # generated by the internal JavaScript server running the Chrome's V8 engine
  # with node.js and some other libraries.
  #
  # Parameters:
  # * phr_record a profile record
  # * debug - a flag indicating whether or not to show the debugging message
  def reminders
    begin
      @access_level, @profile = get_profile("reminders",
                                            ProfilesUser::READ_ONLY_ACCESS,
                                            @phr_record.id_shown)
      options = {"debug" => params[:debug].to_s, "refresh"=>params[:refresh]}
      reminders_by_profiles, debug_info = get_reminder_details([@profile],
                                                               options)
      message_map, creation_date, debug_str =
                                        reminders_by_profiles[@profile.id_shown]
      rtn = message_map.values
      if params[:debug]
        rtn << debug_str if debug_str
        rtn << debug_info if debug_info
      end
      @reminders = rtn.join("<br/>")
      @page_title = "Health Reminders for #{@phr_record.phr.pseudonym_was}" +
        " (Created on #{creation_date})"
    rescue Exception => e
      SystemError.record_server_error(e, request, session)
      raise e
    end
  end


  # Returns data to be used for setting up message managers for the profiles
  # associated with current user. The data is a hash from profile's id_shown
  # to an array of two message manager properties: messageMap_ and
  # reviewedMessageKeys_
  #
  # Parameters:
  # * @user the currently logged in user
  # * debug a flag indicating whether debugging information should be included
  #   in the returned json string
  def message_managers
    begin
      #profiles = @user.active_profiles
      profiles = @user.accessible_profiles
      options = { "return_type"=>"initializer", "page_view"=> "default",
                  "debug" => params[:debug].to_s,
                  "refresh"=>params[:refresh]}
      reminders_by_profiles, debug_info = get_reminder_details(profiles, options)
      render json: [reminders_by_profiles]
    rescue Exception => e
      SystemError.record_server_error(e, request, session)
      raise e
    end
  end


  # PUT /phr_record/1/archive
  # Archives the record
  def archive
    @phr_record.archived = true
    @phr_record.save!
    flash[:notice] = "Archived record for #{@phr_record.phr.pseudonym}."
    redirect_to(phr_records_url)
  end


  # PUT /phr_record/1/unarchive
  # Unarchives the record
  def unarchive
    @phr_record.archived = false
    @phr_record.save!
    flash[:notice] = "Unarchived record for #{@phr_record.phr.pseudonym}."
    redirect_to(archived_phr_records_url)
  end


  # GET /phr_records/1/edit_phr
  # For editing the other top-level fields not handled by the edit action
  def edit_phr
    load_edit_phr_vars
  end


  # PUT /phr_records/1/update_phr
  # For editing the other top-level fields not handled by the edit action
  def update_phr
    phr = @phr_record.phr
    phr_params = params[:phr]

    phr.pregnant_C = phr_params[:pregnant_C]
    phr.due_date = phr_params[:due_date]
    if save_record(phr)
      redirect_to phr_record_path, :notice=>CHANGES_SAVED
    else
      load_edit_phr_vars
      flash.now[:error] = phr.build_error_messages(@@labels)
      # By doing a render rather than a redirect back to edit, we can keep
      # the user's input (in the "phr" object)
      render :action => 'edit_phr'
    end
  end


  # Shows a form for exporting, and also handles the export form.
  def export
    load_class_vars
#    @fds = @@fds
#    @file_formats = []
#    ctd = @fds['file_format'].control_type_detail
#    list_name = ctd['list_name']
#    disp_field = ctd['fields_displayed'][0]
#    TextList.find_by_list_name(list_name).text_list_items.each do |tli|
#      @file_formats << [tli.send(disp_field), tli.code]
#    end
    if request.post?
      phr_params = params[:phr]
#      format = phr_params[:file_format]
      format = '2'      # excel
      handle_export_request(@phr_record, format)
    end
    @page_title = "Export of records for #{@phr_record.phr.pseudonym}"
  end


  private


  # Returns a list made of a hash and a string of debug information. The hash
  # object could have different formats based on different needs controlled by
  # the return_type parameter:
  # 1) For setting up message managers: (when return_type is 'initializer')
  #    { id_shown =>[ msg_map, reminder_creation_date, reviewed_msg_keys, debug_info], ...}
  #    where msg_map and reviewed_msg_keys are related to the two properties of
  #    message manager object on the client side (see Def.MessageManager)
  # 2) For rendering formated reminder messages: (when return_type is nil)
  #    { id_shown =>[ reminders, reminder_creation_date, debug_info],  ...}
  #    where reminders has a list of reminder messages
  #
  # Parameters:
  # * profiles the list of input profiles
  # * options a hash containing the following key/values:
  # *  1) refresh a flag indicating whether the reminder cache needs to be re-generated
  # *  2) For details of other options, see method: get_reminder_details_from_cache
  def get_reminder_details(profiles, options)
    refresh = options.delete("refresh")
    profiles.each{|e| HealthReminder.expire_cache(e)} if refresh
    get_reminder_details_from_cache(profiles, options)
  end


  # Loads the reminder details from cache. If the cache does not exist or expired, generate
  # the cache before loading reminder details information
  #
  # Parameters:
  # * profiles the list of input profiles
  # * options a hash containing the following key/values:
  # *  1) return_type the type of message information to be returned. There is only one type:
  #       a) 'initializer' means the parameters for setting up
  #         messageManager object (including messageMap and reviewed message
  #         list) will be returned.
  # *  2) For details of other options, see method: generate_reminder_details
  def get_reminder_details_from_cache(profiles, options)
    s_total = Time.now
    load_status = options.delete("return_type") == "initializer"
    # For new profile or profiles with outdated reminders, re-generate and cache the reminders
    # The input profiles will be reloaded to update the reminders_created_on attributes
    profiles_grc = profiles.select{|e| !HealthReminder.has_cache?(e) }
    debug_info = ''
    if !profiles_grc.empty?
      debug_info += generate_reminder_details(profiles_grc, options)
      # refresh the obsoleted profile attribute: reminders_created_on
      profiles.each{|e| e.reload}
    end

    # Load the cached reminder information
    id_shown_to_reminder_details = HealthReminder.load_details(profiles, load_status, @user.id)

    d_total = Time.now - s_total
    debug_info += "<hr><h>Time for loading cached reminder data is #{d_total*1000} ms</h>"
    [id_shown_to_reminder_details, debug_info]
  end


  # Generates and caches the reminder details for the input profiles
  #
  # Parameters:
  # * profiles the list of input profiles
  # * options a hash containing the following key/values:
  # *  1) debug a flag indicating whether its the debugging mode or not(default
  #       to true)
  # *  2) page_view either 'default' or 'basic'. This option is used for customizing
  #       the reminders based on page view.
  def generate_reminder_details(profiles, options)
    s_total= Time.now
    options = { "page_view" => 'basic', "debug" => "true" }.merge(options)
    # make sure cache only works in production mode
    @@rmd_cache = nil if Rails.env !="production"
    if !defined?(@@rmd_cache) || @@rmd_cache.nil?
      @@rmd_cache = {}
      @@rmd_cache["fd"]=FormData.new("phr")
      # JavaScript server uri for retrieving reminders.
      # See /lib/js_server/config.json for details
      file_path = Rails.root.join(JS_SERVER_CONF_FILE)
      js_config = JSON.parse(File.read(file_path))
      @@rmd_cache["post_uri"] = js_config["uri"]
    end

    s_gen = Time.now
    # Check to see if the REMINDER_RULE_DATA_JS_FILE exists
    # There are two cases when the file is missing:
    # 1) In the application source code git repository
    # 2) After creating, editing or deleting of any dat rule via the PHR data
    #    rule management pages (i.e.  /rules)
    asset_path = JsGenerator.get_asset_fullpath(REMINDER_RULE_DATA_JS_FILE)
    if !asset_path
      JsGenerator.generate_reminder_rule_data_js
      @@rmd_cache["js_files"] = nil
    end

    # Caching the JavaScript assets
    if !@@rmd_cache["js_files"]
      js_files = []
      if !Rails.application.config.assets.debug
        # Use the compiled, fingerprinted assets
        js_files << Rails.root.join('public/assets',
          Rails.application.assets_manifest.assets[REMINDER_RULE_SYSTEM_JS_FILE])
      else
        # Read the manifest file and add the files in it to the list
        File.readlines(Rails.root.join('app/assets/javascripts',
              REMINDER_RULE_SYSTEM_JS_FILE)).each do |line|
          if (line =~ /(\S+\.js)/)
            js_files << Rails.root.join('app/assets/javascripts', $1)
          end
        end
      end
      js_files << JsGenerator.get_asset_fullpath(REMINDER_RULE_DATA_JS_FILE)
      @@rmd_cache["js_files"] = js_files
    end
    d_gen = Time.now - s_gen

    post_opts = options.merge({"js_files"=> @@rmd_cache["js_files"].join(",")})

    s_taffy = Time.now
    data_tables = nil
    autosaves = AutosaveTmp.where("base_rec"=>true, "form_name"=>"phr",
                                  "profile_id"=>profiles.map(&:id))
    if ( autosaves && (autosaves.size == profiles.size))
      pf ={}; profiles.each{|e|  pf[e.id.to_s] = e.id_shown}
      data_tables = autosaves.map do |as|
        "\"#{pf[as.profile_id]}\"" + ":" + as.data_table
      end.join(",")
      data_tables = "[{#{data_tables}}]"
    else
      data_tables = {}
      profiles.each do |profile|
        user_data = @@rmd_cache["fd"].get_data_table_by_profile(profile.id)
        data_tables[profile.id_shown] = user_data
        # commented out per Frank 8/14/14
        # AutosaveTmp.set_autosave_base(@user, profile.id, "phr", user_data, false, false)
      end
      data_tables = [data_tables].to_json
    end
    # JavaScript eval() cannot covert back the Hash object from its json
    # format. But it work okay with the Array object
    post_opts["profiles"] = data_tables
    d_taffy = Time.now - s_taffy

    # Sends post request to retrieve the reminders
    s_post = Time.now
    resp = Net::HTTP.post_form(URI(@@rmd_cache["post_uri"]), post_opts)
    d_post = (Time.now - s_post)
    d_total = (Time.now - s_total)

    reminders_str = resp.body
    # Removes the anchors for the more/less links
    reminders_str = reminders_str.gsub(/\s*\(more\)\s*/, " ") if reminders_str.index("more")
    rtn = JSON.parse(reminders_str)[0]

    # Cache the reminders by
    # 1) Update the reminder creation timestamp on the profile
    # 2) Outdate the old reminders
    # 3) Create new reminder records if they cannot be found in the newly generated reminders list
    s_backup = Time.now
    rtn.each_key do |id_shown|
      message_map = rtn[id_shown][0]
      creation_date = rtn[id_shown][1]
      HealthReminder.update_reminders_for_profile(id_shown, message_map, creation_date)
    end
    d_backup = Time.now - s_backup

    debug_info =[
        "******************************************************",
        "<h>Time for loading taffydb is #{d_taffy*1000}  ms</h>",
        "<h>Time for making generated js file is #{d_gen*1000}  ms</h>",
        "<h>Time for completing post request is #{d_post*1000}  ms</h>",
        "<h>Time for caching reminder data is #{d_backup*1000}  ms</h>",
        "<h>Time for completing this action is #{d_total*1000}  ms</h>"
      ].join("<br/>") if options["debug"] == "true"
    debug_info || ''
  end


  # A before filter to load @phr_record based on the :id parameter in the URL.
  def load_phr_record
    super(params[:id])
  end


  # Loads the class variables needed for the edit basic information page and
  # the export page.
  def load_class_vars
    if !defined? @@fds
      # Load the field descriptions for the fields we might need.
      @@fds = {}
      {'phr_home'=>%w{gender race_or_ethnicity birth_date pseudonym},
       'phr'=>%w{pregnant due_date}}.each do |form_name, form_fields|
        phr_form = Form.find_by_form_name(form_name)
        form_fds = phr_form.field_descriptions
        # It happens that the data column names are the same as the target
        # field columns names in this model.
        form_fields.each do |f|
          @@fds[f] = form_fds.find_by_target_field(f)
        end
      end
      @@labels = {}
      @@fds.each {|name, fd| @@labels[fd.target_field] = fd.display_name}
    end
  end


  # Loads the instance variables needed by both the new and the edit pages.
  def load_new_edit_vars
    load_class_vars
    @fds = @@fds
    @labels = @@labels
    @gender_list = Phr.gender_list
    @race_list = Phr.race_list
  end

  # Loads the instance variables needed for the edit basic information page
  # (except for @phr_record, because the update action already has that
  # and needs to keep its updated copy when there are errors saving.)
  def load_edit_vars
    load_new_edit_vars

    # For the title, if they changed the pseudonym (and there was some error)
    # then use the original one (via _was).
    @page_title = "Editing PHR Record for #{@phr_record.phr.pseudonym_was}"
  end


  # Loads the instance variables needed by the "new" record page.
  def load_new_vars
    load_new_edit_vars
    @page_title = "New PHR Record"
  end


  # Loads the instance variables needed by the edit_phr action page.
  def load_edit_phr_vars
    load_class_vars
    @fds = @@fds
    @labels = @@labels
    @pregnant_list = Phr.pregnant_list
    # Note:  If we add other fields, we should revise the title.
    @page_title = "Pregnancy Information for #{@phr_record.phr.pseudonym}"
  end


  # A "before filter" to check to make sure that a PHR record about to be
  # viewed or edited does not have autosave data.  Bad things happen if a user
  # edits a record with autosave data and then returns to the standard mode
  # and tries to load the main PHR form, because the data is no longer in sync
  # with the autosave data.  We handle this by making the user choose
  # to drop their autosave data if they wish to continue.
  def check_for_autosave
    if !params[:drop] && @phr_record.has_autosave?
      @page_title = "Autosave Warning"
      render 'autosave_warning'
    elsif @phr_record.has_autosave?
      # In this case the user has chosen to drop the autosave data
      @phr_record.delete_autosave
    end
  end
end
